name: Publish Beta (Manual)

on:
    workflow_dispatch:
        inputs:
            version:
                description: 'Semantic version number (e.g., 1.0.0) - beta suffix will be added automatically'
                required: false
                type: string

jobs:
    prepare:
        runs-on: ubuntu-latest
        outputs:
            version: ${{ steps.version.outputs.version }}
        steps:
            - name: Checkout git repo
              uses: actions/checkout@v1

            - name: Install Node and PNPM
              uses: pnpm/action-setup@v4.1.0
              with:
                  version: 9

            - name: Install dependencies
              run: pnpm install

            - name: Validate and set version with beta suffix
              id: version
              shell: pwsh
              run: |
                  $inputVersion = "${{ github.event.inputs.version }}"
                  Write-Host "Input version: $inputVersion"

                  if ($inputVersion -eq "" -or $inputVersion -eq "null") {
                      # No input version provided, auto-increment patch version
                      Write-Host "No version provided, auto-incrementing patch version..."

                      # Get current version from package.json
                      $currentVersion = (Get-Content package.json | ConvertFrom-Json).version
                      Write-Host "Current version: $currentVersion"

                      # Remove any existing suffix (like -beta) to get clean semantic version
                      $cleanVersion = $currentVersion -replace '-.*$', ''

                      # Extract major, minor, patch components
                      $versionParts = $cleanVersion.Split('.')
                      if ($versionParts.Length -ne 3) {
                          Write-Error "Current version format is invalid: $cleanVersion"
                          exit 1
                      }

                      $major = [int]$versionParts[0]
                      $minor = [int]$versionParts[1]
                      $patch = [int]$versionParts[2]

                      # Increment patch version
                      $newPatch = $patch + 1
                      $inputVersion = "$major.$minor.$newPatch"
                      Write-Host "Auto-generated version: $inputVersion"
                  } else {
                      # Validate semantic version format (major.minor.patch)
                      $versionPattern = '^\d+\.\d+\.\d+$'
                      if ($inputVersion -notmatch $versionPattern) {
                          Write-Error "Invalid version format. Expected semantic version (e.g., 1.0.0), got: $inputVersion"
                          exit 1
                      }
                  }

                  # Add beta suffix
                  $versionWithBeta = "$inputVersion-beta"
                  Write-Host "Setting version to: $versionWithBeta"

                  # Update package.json
                  $packageJson = Get-Content package.json | ConvertFrom-Json
                  $packageJson.version = $versionWithBeta
                  $packageJson | ConvertTo-Json -Depth 10 | Set-Content package.json

                  Write-Host "Updated package.json version to: $versionWithBeta"

                  # Set output for other jobs
                  echo "version=$versionWithBeta" >> $env:GITHUB_OUTPUT

            - name: Delete existing releases and tags
              shell: pwsh
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # Get the version that was set in the previous step
                  $versionWithBeta = "${{ steps.version.outputs.version }}"
                  Write-Host "Checking for existing releases with tag: $versionWithBeta"

                  # Delete release by tag if it exists
                  $releaseExists = gh release view $versionWithBeta 2>$null
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "Found existing release with tag $versionWithBeta, deleting it..."
                      gh release delete $versionWithBeta --yes
                      Write-Host "Successfully deleted existing release with tag $versionWithBeta"
                  } else {
                      Write-Host "No existing release found with tag $versionWithBeta"
                  }

                  # Find and delete any releases with isPrerelease "true"
                  Write-Host "Deleting existing prereleases..."
                  Write-Host "Searching for releases with isPrerelease 'true'..."

                  $betaReleases = gh release list --limit 30 --json tagName,isPrerelease,name | ConvertFrom-Json | Where-Object { $_.isPrerelease -eq $true }

                  if ($betaReleases) {
                      Write-Host "Found $($betaReleases.Count) release(s) with isPrerelease 'true':"
                      foreach ($release in $betaReleases) {
                          Write-Host "  - Tag: $($release.tagName), Title: $($release.name)"
                          gh release delete $release.tagName --yes --cleanup-tag
                          Write-Host "  Deleted release with tag: $($release.tagName)"
                      }
                  } else {
                      Write-Host "No releases found with isPrerelease 'true'"
                  }

                  # Delete the tag if it exists (in case release was deleted but tag remained)
                  $tagExists = gh api repos/:owner/:repo/git/refs/tags/$versionWithBeta 2>$null
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "Found existing tag $versionWithBeta, deleting it..."
                      gh api -X DELETE repos/:owner/:repo/git/refs/tags/$versionWithBeta
                      Write-Host "Successfully deleted tag $versionWithBeta"
                  } else {
                      Write-Host "No existing tag found: $versionWithBeta"
                  }

    publish:
        needs: prepare
        runs-on: ${{ matrix.os }}

        strategy:
            matrix:
                os: [windows-latest, macos-latest, ubuntu-latest]

        steps:
            - name: Checkout git repo
              uses: actions/checkout@v1

            - name: Install Node and PNPM
              uses: pnpm/action-setup@v4.1.0
              with:
                  version: 9

            - name: Install dependencies
              run: pnpm install

            - name: Set version from prepare job
              shell: pwsh
              run: |
                  $versionWithBeta = "${{ needs.prepare.outputs.version }}"
                  Write-Host "Setting version from prepare job: $versionWithBeta"

                  # Update package.json with the version from prepare job
                  $packageJson = Get-Content package.json | ConvertFrom-Json
                  $packageJson.version = $versionWithBeta
                  $packageJson | ConvertTo-Json -Depth 10 | Set-Content package.json

                  Write-Host "Updated package.json version to: $versionWithBeta"

            - name: Build and Publish releases (Windows)
              if: matrix.os == 'windows-latest'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  EP_PRE_RELEASE: true
              uses: nick-invision/retry@v2.8.2
              with:
                  timeout_minutes: 30
                  max_attempts: 3
                  retry_on: error
                  command: |
                      pnpm run package:win
                      pnpm run publish:win
                  on_retry_command: pnpm cache delete

            - name: Build and Publish releases (macOS)
              if: matrix.os == 'macos-latest'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  EP_PRE_RELEASE: true
              uses: nick-invision/retry@v2.8.2
              with:
                  timeout_minutes: 30
                  max_attempts: 3
                  retry_on: error
                  command: |
                      pnpm run package:mac
                      pnpm run publish:mac
                  on_retry_command: pnpm cache delete

            - name: Build and Publish releases (Linux)
              if: matrix.os == 'ubuntu-latest'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  EP_PRE_RELEASE: true
              uses: nick-invision/retry@v2.8.2
              with:
                  timeout_minutes: 30
                  max_attempts: 3
                  retry_on: error
                  command: |
                      pnpm run package:linux
                      pnpm run publish:linux
                  on_retry_command: pnpm cache delete

            - name: Build and Publish releases (Linux ARM64)
              if: matrix.os == 'ubuntu-latest'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  EP_PRE_RELEASE: true
              uses: nick-invision/retry@v2.8.2
              with:
                  timeout_minutes: 30
                  max_attempts: 3
                  retry_on: error
                  command: |
                      pnpm run package:linux-arm64
                      pnpm run publish:linux-arm64
                  on_retry_command: pnpm cache delete

    rename-release:
        needs: [prepare, publish]
        runs-on: ubuntu-latest
        steps:
            - name: Checkout git repo
              uses: actions/checkout@v1

            - name: Rename release title to Beta
              shell: pwsh
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # Get the version from the prepare job
                  $versionWithBeta = "${{ needs.prepare.outputs.version }}"
                  $tagVersion = "v" + $versionWithBeta
                  Write-Host "Renaming release title for tag: $tagVersion"

                  # Check if release exists
                  $releaseExists = gh release view $tagVersion 2>$null
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "Found release with tag $tagVersion, renaming title to 'Beta'..."

                      # Get current release notes
                      $releaseNotes = gh release view $tagVersion --json body --jq '.body'

                      # Update the release with new title
                      gh release edit $tagVersion --title "Beta" --notes "$releaseNotes"
                      Write-Host "Successfully renamed release title to 'Beta'"
                  } else {
                      Write-Host "No release found with tag $tagVersion"
                  }
